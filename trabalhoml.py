# -*- coding: utf-8 -*-
"""trabalhoML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q0x8wCaBvK6oLq9m5bwN5b-5WBmhLyjM

Importando bibliotecas padrões e os conjuntos de dados
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score

df = pd.read_csv('ds_salaries.csv')

df = df.drop_duplicates() #Removendo Duplicatas

# Selecionar colunas relevantes
columns = ['work_year', 'experience_level','salary_in_usd', 'company_size']
df = df[columns]

def get_summary(dataset):
    print("\nDimensions of dataset \n\n", dataset.shape)
    print("\n\nSummary of dataset \n\n", dataset.describe())
    print("\n\nDatatypes \n\n", dataset.dtypes)
    print("\n\nDataset glimpse \n")
    return(dataset.head(5))

get_summary(df)

from sklearn.preprocessing import LabelEncoder
niveis_experiencia = df['experience_level']
label_encoder = LabelEncoder()
niveis_codificados = label_encoder.fit_transform(niveis_experiencia)
df['experience_level'] = niveis_codificados

tamanho_companhia = df['company_size']
label_encoder = LabelEncoder()
tamanho_codificados = label_encoder.fit_transform(tamanho_companhia)
df['company_size'] = tamanho_codificados


get_summary(df)

# Separar variáveis independentes (X) e variável dependente (y)
X = df[columns]
y = df['salary_in_usd']

# Converter variáveis categóricas em variáveis dummy
X = pd.get_dummies(X)

# Verificar a quantidade de valores ausentes em cada coluna
print(df.isnull().sum())

# Dividir os dados em conjunto de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

from sklearn.linear_model import LinearRegression

"""Criar e treinar o modelo de regressão Linear"""

model = LinearRegression()
model.fit(X_train, y_train)

# Fazer previsões no conjunto de teste
y_pred = model.predict(X_test)

# Avaliar o desempenho do modelo
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

# Exibir os resultados
print('Regressão Linear:')
print('MSE:', mse)
print('R2 Score:', r2)

"""Criar e treinar o modelo de Árvore de Decisão"""

from sklearn.tree import DecisionTreeRegressor

# Criar e treinar o modelo de Árvore de Decisão
tree_model = DecisionTreeRegressor()
tree_model.fit(X_train, y_train)

# Fazer previsões no conjunto de teste usando Árvore de Decisão
y_pred_tree = tree_model.predict(X_test)

# Avaliar o desempenho do modelo de Árvore de Decisão
mse_tree = mean_squared_error(y_test, y_pred_tree)
r2_tree = r2_score(y_test, y_pred_tree)

# Exibir os resultados
print('Árvore de Decisão:')
print('MSE:', mse_tree)
print('R2 Score:', r2_tree)
print()

"""Criar e treinar o modelo de Floresta Aleatória"""

from sklearn.ensemble import RandomForestRegressor

# Criar e treinar o modelo de Floresta Aleatória
forest_model = RandomForestRegressor()
forest_model.fit(X_train, y_train)

# Fazer previsões no conjunto de teste usando Floresta Aleatória
y_pred_forest = forest_model.predict(X_test)

# Avaliar o desempenho do modelo de Floresta Aleatória
mse_forest = mean_squared_error(y_test, y_pred_forest)
r2_forest = r2_score(y_test, y_pred_forest)

print('Floresta Aleatória:')
print('MSE:', mse_forest)
print('R2 Score:', r2_forest)

import matplotlib.pyplot as plt

# Plot dos valores reais vs. previsões
plt.scatter(y_test, y_pred)
plt.xlabel('Valores Reais')
plt.ylabel('Previsões')
plt.title('Gráfico de Dispersão: Valores Reais vs. Previsões')
plt.show()